import { AppwriteException } from '../client.mjs';

// src/services/health.ts
var Health = class {
  constructor(client) {
    this.client = client;
  }
  /**
   * Check the Appwrite HTTP server is up and responsive.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthStatus>}
   */
  get() {
    const apiPath = "/health";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Check the Appwrite Antivirus server is up and connection is successful.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthAntivirus>}
   */
  getAntivirus() {
    const apiPath = "/health/anti-virus";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Check the Appwrite in-memory cache servers are up and connection is successful.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthStatus>}
   */
  getCache() {
    const apiPath = "/health/cache";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getCertificate(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        domain: paramsOrFirst
      };
    }
    const domain = params.domain;
    const apiPath = "/health/certificate";
    const payload = {};
    if (typeof domain !== "undefined") {
      payload["domain"] = domain;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Check the Appwrite database servers are up and connection is successful.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthStatus>}
   */
  getDB() {
    const apiPath = "/health/db";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Check the Appwrite pub-sub servers are up and connection is successful.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthStatus>}
   */
  getPubSub() {
    const apiPath = "/health/pubsub";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueBuilds(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/builds";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueCertificates(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/certificates";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueDatabases(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        name: paramsOrFirst,
        threshold: rest[0]
      };
    }
    const name = params.name;
    const threshold = params.threshold;
    const apiPath = "/health/queue/databases";
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueDeletes(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/deletes";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getFailedJobs(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "name" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        name: paramsOrFirst,
        threshold: rest[0]
      };
    }
    const name = params.name;
    const threshold = params.threshold;
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/health/queue/failed/{name}".replace("{name}", name);
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueFunctions(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/functions";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueLogs(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/logs";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueMails(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/mails";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueMessaging(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/messaging";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueMigrations(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/migrations";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueStatsResources(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/stats-resources";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueUsage(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/stats-usage";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  getQueueWebhooks(paramsOrFirst) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        threshold: paramsOrFirst
      };
    }
    const threshold = params.threshold;
    const apiPath = "/health/queue/webhooks";
    const payload = {};
    if (typeof threshold !== "undefined") {
      payload["threshold"] = threshold;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Check the Appwrite storage device is up and connection is successful.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthStatus>}
   */
  getStorage() {
    const apiPath = "/health/storage";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Check the Appwrite local storage device is up and connection is successful.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthStatus>}
   */
  getStorageLocal() {
    const apiPath = "/health/storage/local";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Check the Appwrite server time is synced with Google remote NTP server. We use this technology to smoothly handle leap seconds with no disruptive events. The [Network Time Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (NTP) is used by hundreds of millions of computers and devices to synchronize their clocks over the Internet. If your computer sets its own clock, it likely uses NTP.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.HealthTime>}
   */
  getTime() {
    const apiPath = "/health/time";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
};

export { Health };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=health.mjs.map